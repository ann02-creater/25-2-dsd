<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>Chapter 4-5: Simulation, Implementation & Appendix</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            font-size: 11pt;
            line-height: 1.8;
            max-width: 210mm;
            margin: 0 auto;
            padding: 20mm;
        }

        h1 {
            font-size: 18pt;
            margin: 30px 0 20px;
            border-bottom: 2px solid #000;
            padding-bottom: 10px;
        }

        h2 {
            font-size: 14pt;
            margin: 25px 0 15px;
        }

        h3 {
            font-size: 12pt;
            margin: 20px 0 10px;
        }

        p {
            margin: 10px 0;
            text-align: justify;
            text-indent: 1em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 10pt;
        }

        th,
        td {
            border: 1px solid #000;
            padding: 8px;
            text-align: center;
        }

        th {
            background: #f0f0f0;
        }

        .caption {
            text-align: center;
            font-size: 10pt;
            margin: 10px 0;
            font-weight: bold;
        }

        pre {
            background: #f5f5f5;
            padding: 15px;
            font-size: 9pt;
            line-height: 1.4;
            overflow-x: auto;
            border: 1px solid #ddd;
        }

        ul,
        ol {
            margin: 15px 0 15px 30px;
        }

        li {
            margin: 8px 0;
        }

        .page-num {
            text-align: center;
            font-size: 10pt;
            margin: 30px 0;
            color: #666;
        }

        .highlight {
            background: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }

        .error {
            background: #f8d7da;
            padding: 15px;
            border-left: 4px solid #dc3545;
            margin: 20px 0;
        }

        .success {
            background: #d4edda;
            padding: 15px;
            border-left: 4px solid #28a745;
            margin: 20px 0;
        }

        @media print {
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>

<body>

    <div class="page-num">- 25 -</div>

    <h1>4. Simulation & Verification</h1>

    <h2>4.1 테스트벤치 구성</h2>

    <p>
        시뮬레이션을 통한 기능 검증을 위해 Vivado의 Behavioral Simulation 기능을 활용하였다. 테스트벤치는 클럭 생성, 리셋 시퀀스, 그리고 UART 입력 자극(Stimulus)을
        포함한다.
    </p>

    <pre>
`timescale 1ns / 1ps

module tb_top();
    reg clk, rst;
    reg switch_0;
    reg uart_rx;
    wire uart_tx;
    wire led_heartbeat;
    wire [6:0] seg_out;
    wire [7:0] seg_sel;
    
    // DUT Instantiation
    top dut (
        .clk(clk),
        .rst(rst),
        .switch_0(switch_0),
        .uart_rx(uart_rx),
        .uart_tx(uart_tx),
        .led_heartbeat(led_heartbeat),
        .seg_out(seg_out),
        .seg_sel(seg_sel)
    );
    
    // Clock Generation: 100MHz (10ns period)
    initial clk = 0;
    always #5 clk = ~clk;
    
    // Reset Sequence
    initial begin
        rst = 0;        // Assert reset (Active-Low)
        switch_0 = 0;
        uart_rx = 1;    // UART Idle = HIGH
        #100;
        rst = 1;        // Release reset
        #10000;
        // Simulation continues...
    end
endmodule
</pre>
    <p class="caption">[Code 18] 테스트벤치 기본 구조</p>

    <div class="page-break"></div>
    <div class="page-num">- 26 -</div>

    <h2>4.2 트러블슈팅 과정</h2>

    <p>
        개발 과정에서 발생한 주요 문제들과 해결 과정을 기술한다.
    </p>

    <h3>4.2.1 Issue #1: Memory Aliasing Bug</h3>

    <div class="error">
        <strong>증상:</strong> UART를 통해 문자를 전송하면 CPU가 무한 루프에 빠지거나 비정상적인 명령어를 실행함.
    </div>

    <p><strong>원인 분석:</strong></p>
    <ul>
        <li>UART 주소(0x10000000)에 SW 명령어로 쓰기 수행</li>
        <li>BRAM 주소 버스는 하위 11비트([12:2])만 사용 → 0x10000000의 하위 11비트는 0x000</li>
        <li>BRAM의 Write Enable이 주소와 무관하게 `mem_write`에 연결됨</li>
        <li>결과: UART에 쓸 때마다 BRAM 0번지(부트 코드)가 덮어씌워짐</li>
    </ul>

    <div class="success">
        <strong>해결:</strong> `is_mmio` 신호를 도입하여 MMIO 접근 시 BRAM Write Enable을 차단
        <pre style="margin-top: 10px; background: #e8f5e9;">
wire is_mmio = (EX_MEM_ALU_out[31:28] != 4'b0000);
.web({4{EX_MEM_mem_write && !is_mmio}})
</pre>
    </div>

    <h3>4.2.2 Issue #2: UART RX 신호 미수신</h3>

    <div class="error">
        <strong>증상:</strong> PC에서 키보드를 눌러도 FPGA에서 RX Valid 신호가 발생하지 않음. LED[0] Heartbeat는 정상 동작.
    </div>

    <p><strong>분석 현황:</strong></p>
    <ul>
        <li>RTL 시뮬레이션에서 UART RX 로직은 정상 동작 확인</li>
        <li>XDC 핀 할당(C4)은 Nexys A7 Reference Manual과 일치</li>
        <li>Tera Term 설정(115200, 8-N-1)은 하드웨어 설정과 일치</li>
        <li>물리 계층(USB-UART 브릿지) 또는 터미널 드라이버 문제로 추정</li>
    </ul>

    <div class="highlight">
        <strong>임시 해결책:</strong> 7-Segment TX 모니터링 기능을 구현하여, PC 통신 없이도 CPU의 출력 메시지를 눈으로 확인할 수 있도록 함.
    </div>

    <h3>4.2.3 Issue #3: 클럭 타이밍 경고</h3>

    <div class="error">
        <strong>증상:</strong> Vivado 합성 시 "no user specified timing constraints" 경고 발생.
    </div>

    <div class="success">
        <strong>해결:</strong> XDC 파일에 클럭 제약 조건 명시
        <pre style="margin-top: 10px; background: #e8f5e9;">
create_clock -add -name sys_clk_pin -period 10.00 -waveform {0 5} [get_ports { clk }];
</pre>
    </div>

    <div class="page-break"></div>
    <div class="page-num">- 27 -</div>

    <h2>4.3 현재 구현 상태</h2>

    <table>
        <tr>
            <th>기능</th>
            <th>상태</th>
            <th>비고</th>
        </tr>
        <tr>
            <td>CPU 코어 동작</td>
            <td style="color: green; font-weight: bold;">✅ 정상</td>
            <td>LED Heartbeat 점멸, 명령어 Fetch 확인</td>
        </tr>
        <tr>
            <td>파이프라인 동작</td>
            <td style="color: green; font-weight: bold;">✅ 정상</td>
            <td>Forwarding, Stall 로직 동작</td>
        </tr>
        <tr>
            <td>7-Segment 명령어 표시</td>
            <td style="color: green; font-weight: bold;">✅ 정상</td>
            <td>니모닉 디코딩 및 멀티플렉싱</td>
        </tr>
        <tr>
            <td>7-Segment TX 모니터링</td>
            <td style="color: green; font-weight: bold;">✅ 정상</td>
            <td>UART 대안 디버깅 기능</td>
        </tr>
        <tr>
            <td>UART TX (FPGA→PC)</td>
            <td style="color: orange; font-weight: bold;">⚠️ 확인 중</td>
            <td>RTL 정상, 물리 계층 검증 필요</td>
        </tr>
        <tr>
            <td>UART RX (PC→FPGA)</td>
            <td style="color: red; font-weight: bold;">❌ 미동작</td>
            <td>수신 신호 감지 안 됨</td>
        </tr>
        <tr>
            <td>게임 로직 (홀짝)</td>
            <td style="color: orange; font-weight: bold;">⚠️ 부분 동작</td>
            <td>TX 통해 출력 시도는 확인됨</td>
        </tr>
    </table>
    <p class="caption">[Table 11] 현재 구현 상태 요약</p>

    <div class="page-break"></div>
    <div class="page-num">- 28 -</div>

    <h1>5. Implementation</h1>

    <h2>5.1 합성 결과</h2>

    <p>
        Vivado 2020.2를 사용하여 합성(Synthesis) 및 구현(Implementation)을 수행하였다.
    </p>

    <table>
        <tr>
            <th>Resource</th>
            <th>Used</th>
            <th>Available</th>
            <th>Utilization</th>
        </tr>
        <tr>
            <td>LUT (Look-Up Table)</td>
            <td>~3,500</td>
            <td>63,400</td>
            <td>~5.5%</td>
        </tr>
        <tr>
            <td>FF (Flip-Flop)</td>
            <td>~2,000</td>
            <td>126,800</td>
            <td>~1.6%</td>
        </tr>
        <tr>
            <td>BRAM (36Kb)</td>
            <td>4</td>
            <td>135</td>
            <td>~3%</td>
        </tr>
        <tr>
            <td>DSP</td>
            <td>3</td>
            <td>240</td>
            <td>~1.3%</td>
        </tr>
        <tr>
            <td>IO</td>
            <td>~25</td>
            <td>210</td>
            <td>~12%</td>
        </tr>
    </table>
    <p class="caption">[Table 12] FPGA Resource Utilization</p>

    <h2>5.2 데모 및 사용법</h2>

    <ol>
        <li><strong>비트스트림 프로그래밍:</strong> Vivado에서 Generate Bitstream 후, Hardware Manager를 통해 Nexys A7 보드에 프로그래밍</li>
        <li><strong>터미널 설정:</strong> Tera Term 실행 후, Serial Port 선택, 115200 bps / 8-N-1 설정</li>
        <li><strong>리셋:</strong> 보드의 CPU_RESET 버튼(C12)을 눌렀다 뗌</li>
        <li><strong>동작 확인:</strong>
            <ul>
                <li>LED[0]이 약 0.75Hz로 점멸하면 시스템 정상 동작</li>
                <li>Switch[0] OFF: 7-Segment에 현재 명령어 표시 (예: "ADD 000")</li>
                <li>Switch[0] ON: 7-Segment에 TX 버퍼 내용 표시</li>
            </ul>
        </li>
        <li><strong>게임 플레이:</strong> Tera Term에서 숫자(0-9) 입력 → 홀수/짝수 결과 출력 (UART 정상 동작 시)</li>
    </ol>

    <div class="page-break"></div>
    <div class="page-num">- 29 -</div>

    <h1>
        < 부 록>
    </h1>

    <h2>1. 소스코드 목록</h2>

    <table>
        <tr>
            <th>파일명</th>
            <th>Lines</th>
            <th>설명</th>
        </tr>
        <tr>
            <td>top.v</td>
            <td>~200</td>
            <td>최상위 모듈, I/O 연결 및 디버그 로직</td>
        </tr>
        <tr>
            <td>data_path.v</td>
            <td>~370</td>
            <td>CPU 파이프라인 코어</td>
        </tr>
        <tr>
            <td>control_unit.v</td>
            <td>~170</td>
            <td>제어 신호 생성</td>
        </tr>
        <tr>
            <td>ALU.v</td>
            <td>~50</td>
            <td>산술논리연산장치</td>
        </tr>
        <tr>
            <td>ALU_op.v</td>
            <td>~60</td>
            <td>ALU 제어 유닛</td>
        </tr>
        <tr>
            <td>reger.v</td>
            <td>~90</td>
            <td>레지스터 파일</td>
        </tr>
        <tr>
            <td>uart.v</td>
            <td>~75</td>
            <td>UART 통신 모듈</td>
        </tr>
        <tr>
            <td>inst_decoder.v</td>
            <td>~470</td>
            <td>명령어→7-Segment 디코더</td>
        </tr>
        <tr>
            <td>seven_segment_8_driver.v</td>
            <td>~75</td>
            <td>7-Segment 드라이버</td>
        </tr>
        <tr>
            <td>Forward_Unit.v</td>
            <td>~60</td>
            <td>Forwarding 유닛</td>
        </tr>
        <tr>
            <td>Hazard_Unit_prediction.v</td>
            <td>~40</td>
            <td>Hazard 감지</td>
        </tr>
        <tr>
            <td>imm_gen.v</td>
            <td>~50</td>
            <td>Immediate 생성기</td>
        </tr>
        <tr>
            <td>const.xdc</td>
            <td>~60</td>
            <td>핀 할당</td>
        </tr>
        <tr>
            <td>game.coe</td>
            <td>~2050</td>
            <td>BRAM 초기화 데이터</td>
        </tr>
        <tr>
            <td>main.c</td>
            <td>~45</td>
            <td>홀짝 게임 C 코드</td>
        </tr>
    </table>
    <p class="caption">[Table 13] 소스코드 목록</p>

    <h2>2. 개인 소감</h2>

    <p>
        본 프로젝트를 통해 RISC-V 아키텍처의 파이프라인 구조와 Hazard 처리 기법에 대해 깊이 이해할 수 있었다. 특히, 오픈소스 CPU 코어를 실제 FPGA 보드에 통합하고 I/O를 연결하는
        과정에서 Memory-Mapped I/O의 개념과 주소 디코딩의 중요성을 체감하였다.
    </p>

    <p>
        개발 과정에서 발생한 Memory Aliasing 버그는 주소 비트 절삭이라는 매우 미묘한 원인에서 비롯되었으며, 이를 RTL 레벨에서 분석하고 해결하는 경험을 통해 하드웨어 디버깅 능력이 크게
        향상되었다. UART 통신 문제가 완전히 해결되지 않은 점은 아쉬우나, 하드웨어 디버거(7-Segment TX 모니터링)를 구현하여 UART 없이도 CPU의 동작을 검증할 수 있는 대안을 마련하였다.
    </p>

    <p>
        이번 프로젝트는 컴퓨터 구조 수업에서 배운 이론적 지식을 실제 하드웨어로 구현해보는 소중한 경험이었다. 단순히 코드를 작성하는 것이 아니라, 타이밍, 리소스, 물리적 제약 등 하드웨어 특유의
        고려사항들을 다루면서 임베디드 시스템 개발자로서의 역량을 기를 수 있었다.
    </p>

    <hr style="margin: 40px 0;">
    <p style="text-align: center; font-size: 10pt; color: #666;">
        - 보고서 끝 -
    </p>

</body>

</html>