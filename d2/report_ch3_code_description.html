<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <title>Chapter 3: Code Description</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            font-size: 11pt;
            line-height: 1.8;
            max-width: 210mm;
            margin: 0 auto;
            padding: 20mm;
        }

        h1 {
            font-size: 18pt;
            margin: 30px 0 20px;
            border-bottom: 2px solid #000;
            padding-bottom: 10px;
        }

        h2 {
            font-size: 14pt;
            margin: 25px 0 15px;
        }

        h3 {
            font-size: 12pt;
            margin: 20px 0 10px;
        }

        p {
            margin: 10px 0;
            text-align: justify;
            text-indent: 1em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 10pt;
        }

        th,
        td {
            border: 1px solid #000;
            padding: 8px;
            text-align: left;
        }

        th {
            background: #f0f0f0;
            text-align: center;
        }

        .caption {
            text-align: center;
            font-size: 10pt;
            margin: 10px 0;
            font-weight: bold;
        }

        .diagram {
            background: #f8f9fa;
            border: 1px solid #ddd;
            padding: 20px;
            margin: 20px 0;
        }

        .diagram pre {
            font-size: 9pt;
            line-height: 1.3;
            margin: 0;
        }

        pre {
            background: #f5f5f5;
            padding: 15px;
            font-size: 8pt;
            line-height: 1.4;
            overflow-x: auto;
            border: 1px solid #ddd;
        }

        code {
            background: #f0f0f0;
            padding: 2px 5px;
            font-family: Consolas, monospace;
            font-size: 10pt;
        }

        ul,
        ol {
            margin: 15px 0 15px 30px;
        }

        li {
            margin: 8px 0;
        }

        .page-num {
            text-align: center;
            font-size: 10pt;
            margin: 30px 0;
            color: #666;
        }

        @media print {
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>

<body>

    <div class="page-num">- 17 -</div>

    <h1>3. Code Description</h1>

    <h2>3.1 Module Hierarchy</h2>

    <p>
        본 프로젝트의 전체 모듈 계층 구조는 다음과 같다. 최상위 모듈인 <code>top.v</code>가 CPU 코어(<code>data_path</code>), 통신
        모듈(<code>uart</code>), 그리고 디스플레이 모듈(<code>inst_decoder</code>, <code>seven_segment_8_driver</code>)을 인스턴스화한다.
    </p>

    <div class="diagram">
        <pre>
top.v (Top Module)
│
├── data_path.v (CPU Core) ────────────────────────────────────────────────────────────────────────
│   │
│   ├── blk_mem_gen_0 (Vivado BRAM IP) ─── 8KB Dual-Port RAM for Instruction & Data
│   │
│   ├── control_unit.v ─────────────────── Opcode → Control Signals
│   │
│   ├── prv32_ALU.v (ALU) ──────────────── Arithmetic & Logic Operations
│   │   └── shifter.v ──────────────────── Shift Operations (SLL, SRL, SRA)
│   │
│   ├── RegFile (reger.v) ──────────────── 32 x 32-bit Register File
│   │   ├── register.v (32_reg.v) ──────── 32-bit Register with Load Enable
│   │   │   ├── DFlipFlop (reg.v) ──────── D Flip-Flop (1-bit)
│   │   │   └── mux.v ──────────────────── 2:1 Multiplexer
│   │
│   ├── imm_gen.v ──────────────────────── Immediate Value Generator (Sign Extension)
│   │
│   ├── ALU_op.v ───────────────────────── ALU Control Unit (funct3/7 → ALU Op)
│   │
│   ├── branch.v ───────────────────────── Branch Comparator (BEQ, BNE, BLT, etc.)
│   │
│   ├── Forward_Unit.v ─────────────────── Data Hazard: Forwarding Logic
│   │
│   ├── Hazard_Unit_prediction.v ───────── Data Hazard: Stall Detection
│   │
│   ├── multiplexer.v ──────────────────── Generic 2:1 Multiplexer (32-bit)
│   │
│   └── ripple.v (PC Adder) ────────────── PC + 4, PC + Immediate
│
├── uart.v (UART Communication) ────────── 115200 bps, TX & RX
│
├── inst_decoder.v (Instruction Decoder) ─ 32-bit Instruction → 7-Segment Mnemonic
│
└── seven_segment_8_driver.v ───────────── 8-digit 7-Segment Time Multiplexing
</pre>
    </div>
    <p class="caption">[Figure 5] Module Hierarchy</p>

    <div class="page-break"></div>
    <div class="page-num">- 18 -</div>

    <h2>3.2 Top-Module (top.v)</h2>

    <p>
        시스템의 최상위 모듈로, 모든 하위 모듈을 인스턴스화하고 신호를 연결한다. 특히 최근 수정 사항으로 7-Segment에 UART 송신 데이터를 시각화하는 디버그 로직이 추가되었다.
    </p>

    <h3>3.2.1 Heartbeat LED 구현</h3>
    <pre>
// Heartbeat LED: 시스템 동작 확인용 (약 0.75Hz 점멸)
reg [25:0] heartbeat_counter;
always @(posedge clk) begin
    if (rst)
        heartbeat_counter <= 0;
    else
        heartbeat_counter <= heartbeat_counter + 1;
end
assign led_heartbeat = heartbeat_counter[25];  // 100MHz / 2^26 ≈ 1.49Hz
</pre>
    <p class="caption">[Code 5] Heartbeat LED 구현</p>

    <h3>3.2.2 TX 버퍼 및 7-Segment 디버그 로직</h3>
    <pre>
// UART TX 버퍼: CPU가 송신하는 마지막 8글자 저장
reg [7:0] tx_buffer [7:0];  // 8-character circular buffer
integer i;

always @(posedge clk) begin
    if (rst) begin
        for(i=0; i<8; i=i+1) tx_buffer[i] <= 8'h20;  // 공백으로 초기화
    end else if (tx_we) begin
        // Shift left, new char enters at index 0
        tx_buffer[0] <= tx_data;
        for(i=1; i<8; i=i+1) tx_buffer[i] <= tx_buffer[i-1];
    end
end

// Switch[0]에 따라 Instruction 또는 TX 버퍼 표시
assign s0 = switch_0 ? char_to_seg(tx_buffer[0]) : seg0_pattern;
assign s1 = switch_0 ? char_to_seg(tx_buffer[1]) : seg1_pattern;
// ... (s2 ~ s7 동일)
</pre>
    <p class="caption">[Code 6] TX 버퍼 및 7-Segment 디버그 로직</p>

    <div class="page-break"></div>
    <div class="page-num">- 19 -</div>

    <h2>3.3 IF Stage (Instruction Fetch)</h2>

    <h3>3.3.1 PC (Program Counter)</h3>
    <p>
        PC는 현재 실행 중인 명령어의 주소를 저장하는 레지스터이다. 매 클럭마다 다음 명령어 주소로 갱신되며, 분기/점프 시에는 새로운 목적지 주소로 변경된다.
    </p>

    <pre>
// PC Register Update
always @(posedge clk) begin
    if (rst)
        PC <= 32'h00000000;
    else if (!stall)
        PC <= final_pc;
end

// PC 계산
wire [31:0] pc_inc_out;        // PC + 4
wire [31:0] pc_gen_out;        // PC + Immediate (Branch Target)
wire [31:0] PC_in;             // MUX 출력 (분기 여부에 따라 선택)

ripple pc_inc (PC, 32'd4, pc_inc_out, dummy_carry);
ripple pc_gen (IF_ID_PC, imm_out, pc_gen_out, dummy_carry);

multiplexer pc_mux (pc_inc_out, pc_gen_out, flag_comp, PC_in);
assign final_pc = (MEM_WB_sys & inst_out[20]) ? PC : PC_in;
</pre>
    <p class="caption">[Code 7] PC 갱신 로직</p>

    <h3>3.3.2 Instruction Memory (BRAM Port A)</h3>
    <p>
        Vivado의 Block Memory Generator IP를 사용하여 True Dual-Port RAM을 구성하였다. Port A는 Instruction Fetch에 사용되며, Read-Only로
        동작한다.
    </p>

    <pre>
blk_mem_gen_0 bram (
    // Port A: Instruction Fetch (Read-Only)
    .clka(clk),
    .ena(1'b1),           // Always enabled
    .wea(4'b0),           // Write disabled
    .addra(PC[12:2]),     // Word-aligned address (2048 words)
    .dina(32'b0),
    .douta(inst_mem_out), // 32-bit Instruction output
    
    // Port B: Data Memory (Read/Write)
    .clkb(clk),
    .enb(1'b1),
    .web({4{EX_MEM_mem_write && !is_mmio}}),  // Gated write enable
    .addrb(EX_MEM_ALU_out[12:2]),
    .dinb(EX_MEM_RegR2),
    .doutb(bram_data_out)
);
</pre>
    <p class="caption">[Code 8] BRAM IP 인스턴스화</p>

    <div class="page-break"></div>
    <div class="page-num">- 20 -</div>

    <h3>3.3.3 IF/ID 파이프라인 레지스터</h3>
    <pre>
// IF/ID Pipeline Register
always @(posedge clk) begin
    if (rst | flag_comp) begin
        IF_ID_PC   <= 32'b0;
        IF_ID_Inst <= 32'h00000013;  // NOP (ADDI x0, x0, 0)
    end else if (!stall) begin
        IF_ID_PC   <= PC;
        IF_ID_Inst <= inst_out;
    end
end
</pre>
    <p class="caption">[Code 9] IF/ID 파이프라인 레지스터</p>

    <h2>3.4 ID Stage (Instruction Decode)</h2>

    <h3>3.4.1 Register File (reger.v)</h3>
    <p>
        RISC-V는 32개의 32비트 범용 레지스터(x0 ~ x31)를 가진다. x0 레지스터는 항상 0을 유지하며, 쓰기가 무시된다.
    </p>

    <pre>
module RegFile(
    input clk, rst,
    input [4:0] read_addr1, read_addr2, write_addr,
    input [31:0] write_data,
    input reg_write,
    output [31:0] read_data1, read_data2
);
    reg [31:0] registers [31:0];
    
    // Read Logic (Combinational)
    assign read_data1 = (read_addr1 == 0) ? 32'b0 : registers[read_addr1];
    assign read_data2 = (read_addr2 == 0) ? 32'b0 : registers[read_addr2];
    
    // Write Logic (Sequential)
    always @(posedge clk) begin
        if (rst) begin
            for (integer i = 0; i < 32; i = i + 1)
                registers[i] <= 32'b0;
        end else if (reg_write && write_addr != 0) begin
            registers[write_addr] <= write_data;
        end
    end
endmodule
</pre>
    <p class="caption">[Code 10] Register File 구현</p>

    <h3>3.4.2 Immediate Generator (imm_gen.v)</h3>
    <p>
        RISC-V의 다양한 명령어 형식에 따라 즉시값을 추출하고 32비트로 부호 확장한다.
    </p>

    <table>
        <tr>
            <th>Type</th>
            <th>Immediate Bits</th>
            <th>예시 명령어</th>
        </tr>
        <tr>
            <td>I-type</td>
            <td>inst[31:20]</td>
            <td>ADDI, LW, JALR</td>
        </tr>
        <tr>
            <td>S-type</td>
            <td>inst[31:25], inst[11:7]</td>
            <td>SW, SB</td>
        </tr>
        <tr>
            <td>B-type</td>
            <td>inst[31], inst[7], inst[30:25], inst[11:8], 0</td>
            <td>BEQ, BNE</td>
        </tr>
        <tr>
            <td>U-type</td>
            <td>inst[31:12], 12'b0</td>
            <td>LUI, AUIPC</td>
        </tr>
        <tr>
            <td>J-type</td>
            <td>inst[31], inst[19:12], inst[20], inst[30:21], 0</td>
            <td>JAL</td>
        </tr>
    </table>
    <p class="caption">[Table 9] RISC-V Immediate 형식</p>

    <div class="page-break"></div>
    <div class="page-num">- 21 -</div>

    <h2>3.5 EX Stage (Execution)</h2>

    <h3>3.5.1 ALU (prv32_ALU.v)</h3>
    <p>
        ALU는 산술, 논리, 시프트, 비교 연산을 수행한다. ALU Control 신호에 따라 동작이 결정된다.
    </p>

    <pre>
module prv32_ALU(
    input [31:0] a, b,
    input [4:0] shamt,
    output reg [31:0] result,
    output carry, zero, overflow, sign,
    input [3:0] alufn
);
    wire [31:0] sh;  // Shift result
    shifter shifter0(a, shamt, alufn[1:0], sh);
    
    always @(*) begin
        case (alufn)
            4'b0000: result = a + b;                    // ADD
            4'b0001: result = a - b;                    // SUB
            4'b0010: result = a & b;                    // AND
            4'b0011: result = a | b;                    // OR
            4'b0100: result = a ^ b;                    // XOR
            4'b0101: result = sh;                       // SLL
            4'b0110: result = sh;                       // SRL
            4'b0111: result = sh;                       // SRA
            4'b1000: result = ($signed(a) < $signed(b)) ? 1 : 0;  // SLT
            4'b1001: result = (a < b) ? 1 : 0;          // SLTU
            4'b1010: result = a * b;                    // MUL
            default: result = 32'b0;
        endcase
    end
    
    assign zero = (result == 0);
    assign sign = result[31];
endmodule
</pre>
    <p class="caption">[Code 11] ALU 구현 (일부)</p>

    <h3>3.5.2 ALU Control Unit (ALU_op.v)</h3>
    <p>
        Control Unit에서 생성한 ALUOp 신호와 명령어의 funct3, funct7 필드를 조합하여 실제 ALU 연산을 결정한다.
    </p>

    <table>
        <tr>
            <th>ALUOp</th>
            <th>의미</th>
            <th>funct3/7 참조</th>
            <th>예시</th>
        </tr>
        <tr>
            <td>00</td>
            <td>Add</td>
            <td>X</td>
            <td>LW, SW, AUIPC</td>
        </tr>
        <tr>
            <td>01</td>
            <td>Branch</td>
            <td>funct3</td>
            <td>BEQ, BNE</td>
        </tr>
        <tr>
            <td>10</td>
            <td>R-type</td>
            <td>funct3, funct7</td>
            <td>ADD, SUB, AND</td>
        </tr>
        <tr>
            <td>11</td>
            <td>I-type</td>
            <td>funct3</td>
            <td>ADDI, ANDI</td>
        </tr>
    </table>
    <p class="caption">[Table 10] ALUOp 인코딩</p>

    <div class="page-break"></div>
    <div class="page-num">- 22 -</div>

    <h2>3.6 MEM Stage (Memory Access)</h2>

    <h3>3.6.1 MMIO Data MUX</h3>
    <p>
        MEM 단계에서는 Load 명령어 시 BRAM 또는 MMIO 레지스터에서 데이터를 읽어온다. 주소에 따라 적절한 데이터 소스를 선택한다.
    </p>

    <pre>
// Memory-Mapped I/O Read MUX
reg [31:0] data_mem_out;
always @(*) begin
    if (EX_MEM_ALU_out == 32'h1000_0000) begin
        // UART Data Register (RX)
        data_mem_out = {24'b0, uart_rx_data_in};
    end
    else if (EX_MEM_ALU_out == 32'h1000_0004) begin
        // UART Status Register
        data_mem_out = {30'b0, uart_tx_busy_in, uart_rx_valid_in};
    end
    else begin
        // Normal BRAM Access
        data_mem_out = bram_data_out;
    end
end
</pre>
    <p class="caption">[Code 12] MMIO Read MUX</p>

    <h3>3.6.2 MMIO Write Logic</h3>
    <pre>
// Memory-Mapped I/O Write Logic
always @(posedge clk) begin
    if (EX_MEM_mem_write) begin
        if (EX_MEM_ALU_out == 32'h2000_0000) begin
            // LED Control Register
            led_reg_out <= EX_MEM_RegR2[15:0];
        end
        else if (EX_MEM_ALU_out == 32'h1000_0000) begin
            // UART TX: Write data and trigger transmission
            uart_tx_data_out <= EX_MEM_RegR2[7:0];
            uart_tx_we_out <= 1'b1;
        end
        else begin
            uart_tx_we_out <= 1'b0;
        end
    end
    else begin
        uart_tx_we_out <= 1'b0;
    end
end
</pre>
    <p class="caption">[Code 13] MMIO Write Logic</p>

    <h2>3.7 WB Stage (Write Back)</h2>

    <p>
        WB 단계에서는 최종 결과를 레지스터 파일에 기록한다. <code>mem_to_reg</code> 신호에 따라 ALU 결과 또는 메모리 데이터를 선택한다.
    </p>

    <pre>
// Write Back MUX
multiplexer write_back (
    .a(MEM_WB_ALU_out),   // ALU Result
    .b(MEM_WB_Mem_out),   // Memory Read Data
    .sel(MEM_WB_mem_to_reg),
    .out(write_data)      // To Register File
);
</pre>
    <p class="caption">[Code 14] Write Back MUX</p>

    <div class="page-break"></div>
    <div class="page-num">- 23 -</div>

    <h2>3.8 I/O Modules</h2>

    <h3>3.8.1 UART (uart.v)</h3>
    <pre>
module uart (
    input clk, resetn,
    output ser_tx, input ser_rx,
    input [15:0] cfg_divider,    // Baud rate divider (868 for 115200)
    input [7:0] reg_dat_di,      // TX data
    output [7:0] reg_dat_do,     // RX data
    input reg_dat_we,            // TX write enable
    input reg_dat_re,            // RX read acknowledge
    output tx_busy, rx_valid
);
    reg [9:0] tx_shift_reg;      // Start + 8 Data + Stop
    reg [3:0] tx_bit_cnt;
    reg [30:0] tx_cnt;
    reg [9:0] rx_shift_reg;
    reg [3:0] rx_bit_cnt;
    reg [30:0] rx_cnt;
    reg [7:0] rx_data_reg;
    reg rx_valid_reg;
    
    assign ser_tx = tx_shift_reg[0];
    assign tx_busy = (tx_bit_cnt != 0);
    assign rx_valid = rx_valid_reg;
    assign reg_dat_do = rx_data_reg;
    
    always @(posedge clk) begin
        if (!resetn) begin
            tx_shift_reg <= 10'h3FF;  // Idle = HIGH
            tx_bit_cnt <= 0;
            // ... (초기화)
        end else begin
            // Transmitter
            if (tx_cnt) tx_cnt <= tx_cnt - 1;
            else if (tx_bit_cnt) begin
                tx_shift_reg <= {1'b1, tx_shift_reg[9:1]};  // Shift out
                tx_bit_cnt <= tx_bit_cnt - 1;
                tx_cnt <= cfg_divider;
            end else if (reg_dat_we) begin
                tx_shift_reg <= {1'b1, reg_dat_di, 1'b0};  // Stop + Data + Start
                tx_bit_cnt <= 10;
                tx_cnt <= cfg_divider;
            end
            
            // Receiver
            if (reg_dat_re) rx_valid_reg <= 0;
            if (rx_cnt) rx_cnt <= rx_cnt - 1;
            else if (rx_bit_cnt) begin
                rx_shift_reg <= {ser_rx, rx_shift_reg[9:1]};
                rx_bit_cnt <= rx_bit_cnt - 1;
                rx_cnt <= cfg_divider;
                if (rx_bit_cnt == 1) begin
                    rx_data_reg <= rx_shift_reg[9:2];
                    rx_valid_reg <= 1;
                end
            end else if (!ser_rx) begin  // Start bit detected
                rx_cnt <= cfg_divider / 2;
                rx_bit_cnt <= 10;
            end
        end
    end
endmodule
</pre>
    <p class="caption">[Code 15] UART Module 전체 코드</p>

    <div class="page-break"></div>
    <div class="page-num">- 24 -</div>

    <h3>3.8.2 7-Segment Display Driver (seven_segment_8_driver.v)</h3>
    <pre>
module seven_segment_8_driver(
    input clk, rst,
    input [6:0] seg0, seg1, seg2, seg3, seg4, seg5, seg6, seg7,
    output reg [6:0] seg_out,
    output reg [7:0] seg_sel
);
    reg [19:0] refresh_counter;
    wire [2:0] active_digit;
    
    always @(posedge clk) begin
        if (rst) refresh_counter <= 0;
        else     refresh_counter <= refresh_counter + 1;
    end
    
    assign active_digit = refresh_counter[19:17];  // ~190Hz per digit
    
    always @(*) begin
        seg_sel = 8'b11111111;
        seg_out = 7'b1111111;
        
        case (active_digit)
            3'd0: begin seg_sel = 8'b11111110; seg_out = seg0; end
            3'd1: begin seg_sel = 8'b11111101; seg_out = seg1; end
            3'd2: begin seg_sel = 8'b11111011; seg_out = seg2; end
            3'd3: begin seg_sel = 8'b11110111; seg_out = seg3; end
            3'd4: begin seg_sel = 8'b11101111; seg_out = seg4; end
            3'd5: begin seg_sel = 8'b11011111; seg_out = seg5; end
            3'd6: begin seg_sel = 8'b10111111; seg_out = seg6; end
            3'd7: begin seg_sel = 8'b01111111; seg_out = seg7; end
        endcase
    end
endmodule
</pre>
    <p class="caption">[Code 16] 7-Segment Driver 전체 코드</p>

    <h3>3.8.3 Instruction Decoder (inst_decoder.v)</h3>
    <p>
        32비트 명령어를 해석하여 7-Segment에 표시할 니모닉 문자열로 변환한다. 예를 들어, <code>0x00000013</code>은 <code>"ADDI 000"</code>으로 표시된다.
    </p>

    <pre>
// 7-Segment 문자 인코딩 함수
function [6:0] char_to_seg;
    input [7:0] c;
    begin
        case (c)
            "0": char_to_seg = 7'b1000000;
            "1": char_to_seg = 7'b1111001;
            // ... (숫자 0-9)
            "A": char_to_seg = 7'b0001000;
            "B": char_to_seg = 7'b0000011;  // lowercase b
            // ... (알파벳)
            " ": char_to_seg = 7'b1111111;  // blank
            default: char_to_seg = 7'b1111111;
        endcase
    end
endfunction
</pre>
    <p class="caption">[Code 17] 7-Segment 문자 인코딩 (일부)</p>

</body>

</html>